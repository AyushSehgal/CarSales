{"version":3,"sources":["../../src/rules/newlineAfterDescription.js"],"names":["jsdoc","report","context","jsdocNode","sourceCode","indent","always","description","tags","length","_","has","options","descriptionEndsWithANewline","source","slice","startsWith","fixer","sourceLines","getText","split","lastDescriptionLine","findLastIndex","line","includes","last","splice","replaceText","join","meta","fixable","type","schema","enum"],"mappings":";;;;;;;AAAA;;AACA;;;;eAEe,2BAAa,CAAC;AAC3BA,EAAAA,KAD2B;AAE3BC,EAAAA,MAF2B;AAG3BC,EAAAA,OAH2B;AAI3BC,EAAAA,SAJ2B;AAK3BC,EAAAA,UAL2B;AAM3BC,EAAAA;AAN2B,CAAD,KAOtB;AACJ,MAAIC,MAAJ;;AAEA,MAAI,CAACN,KAAK,CAACO,WAAP,IAAsB,CAACP,KAAK,CAACQ,IAAN,CAAWC,MAAtC,EAA8C;AAC5C;AACD;;AAED,MAAIC,gBAAEC,GAAF,CAAMT,OAAO,CAACU,OAAd,EAAuB,CAAvB,CAAJ,EAA+B;AAC7BN,IAAAA,MAAM,GAAGJ,OAAO,CAACU,OAAR,CAAgB,CAAhB,MAAuB,QAAhC;AACD,GAFD,MAEO;AACLN,IAAAA,MAAM,GAAG,IAAT;AACD,GAXG,CAaJ;AACA;AACA;;;AACA,QAAMO,2BAA2B,GAAGb,KAAK,CAACc,MAAN,CAAaC,KAAb,CAAmBf,KAAK,CAACO,WAAN,CAAkBE,MAArC,EAA6CO,UAA7C,CAAwD,MAAxD,CAApC;;AAEA,MAAIV,MAAJ,EAAY;AACV,QAAI,CAACO,2BAAL,EAAkC;AAChCZ,MAAAA,MAAM,CAAC,mEAAD,EAAuEgB,KAAD,IAAW;AACrF,cAAMC,WAAW,GAAGd,UAAU,CAACe,OAAX,CAAmBhB,SAAnB,EAA8BiB,KAA9B,CAAoC,IAApC,CAApB;;AACA,cAAMC,mBAAmB,GAAGX,gBAAEY,aAAF,CAAgBJ,WAAhB,EAA8BK,IAAD,IAAU;AACjE,iBAAOA,IAAI,CAACC,QAAL,CAAcd,gBAAEe,IAAF,CAAOzB,KAAK,CAACO,WAAN,CAAkBa,KAAlB,CAAwB,IAAxB,CAAP,CAAd,CAAP;AACD,SAF2B,CAA5B,CAFqF,CAMrF;;;AACAF,QAAAA,WAAW,CAACQ,MAAZ,CAAmBL,mBAAmB,GAAG,CAAzC,EAA4C,CAA5C,EAA+ChB,MAAM,GAAG,IAAxD;AAEA,eAAOY,KAAK,CAACU,WAAN,CAAkBxB,SAAlB,EAA6Be,WAAW,CAACU,IAAZ,CAAiB,IAAjB,CAA7B,CAAP;AACD,OAVK,CAAN;AAWD;AACF,GAdD,MAcO,IAAIf,2BAAJ,EAAiC;AACtCZ,IAAAA,MAAM,CAAC,oEAAD,EAAwEgB,KAAD,IAAW;AACtF,YAAMC,WAAW,GAAGd,UAAU,CAACe,OAAX,CAAmBhB,SAAnB,EAA8BiB,KAA9B,CAAoC,IAApC,CAApB;;AACA,YAAMC,mBAAmB,GAAGX,gBAAEY,aAAF,CAAgBJ,WAAhB,EAA8BK,IAAD,IAAU;AACjE,eAAOA,IAAI,CAACC,QAAL,CAAcd,gBAAEe,IAAF,CAAOzB,KAAK,CAACO,WAAN,CAAkBa,KAAlB,CAAwB,IAAxB,CAAP,CAAd,CAAP;AACD,OAF2B,CAA5B,CAFsF,CAMtF;;;AACAF,MAAAA,WAAW,CAACQ,MAAZ,CAAmBL,mBAAmB,GAAG,CAAzC,EAA4C,CAA5C;AAEA,aAAOJ,KAAK,CAACU,WAAN,CAAkBxB,SAAlB,EAA6Be,WAAW,CAACU,IAAZ,CAAiB,IAAjB,CAA7B,CAAP;AACD,KAVK,CAAN;AAWD;AACF,CApDc,EAoDZ;AACDC,EAAAA,IAAI,EAAE;AACJC,IAAAA,OAAO,EAAE,YADL;AAEJC,IAAAA,IAAI,EAAE;AAFF,GADL;AAKDC,EAAAA,MAAM,EAAE,CACN;AACEC,IAAAA,IAAI,EAAE,CAAC,QAAD,CADR;AAEEF,IAAAA,IAAI,EAAE;AAFR,GADM;AALP,CApDY,C","sourcesContent":["import _ from 'lodash';\nimport iterateJsdoc from '../iterateJsdoc';\n\nexport default iterateJsdoc(({\n  jsdoc,\n  report,\n  context,\n  jsdocNode,\n  sourceCode,\n  indent\n}) => {\n  let always;\n\n  if (!jsdoc.description || !jsdoc.tags.length) {\n    return;\n  }\n\n  if (_.has(context.options, 0)) {\n    always = context.options[0] === 'always';\n  } else {\n    always = true;\n  }\n\n  // The contents of the jsdoc.source and of jsdoc.description is left trimmed.\n  // The contents of the jsdoc.description is right trimmed.\n  // This gets the text following the description.\n  const descriptionEndsWithANewline = jsdoc.source.slice(jsdoc.description.length).startsWith('\\n\\n');\n\n  if (always) {\n    if (!descriptionEndsWithANewline) {\n      report('There must be a newline after the description of the JSDoc block.', (fixer) => {\n        const sourceLines = sourceCode.getText(jsdocNode).split('\\n');\n        const lastDescriptionLine = _.findLastIndex(sourceLines, (line) => {\n          return line.includes(_.last(jsdoc.description.split('\\n')));\n        });\n\n        // Add the new line\n        sourceLines.splice(lastDescriptionLine + 1, 0, indent + ' *');\n\n        return fixer.replaceText(jsdocNode, sourceLines.join('\\n'));\n      });\n    }\n  } else if (descriptionEndsWithANewline) {\n    report('There must be no newline after the description of the JSDoc block.', (fixer) => {\n      const sourceLines = sourceCode.getText(jsdocNode).split('\\n');\n      const lastDescriptionLine = _.findLastIndex(sourceLines, (line) => {\n        return line.includes(_.last(jsdoc.description.split('\\n')));\n      });\n\n      // Remove the extra line\n      sourceLines.splice(lastDescriptionLine + 1, 1);\n\n      return fixer.replaceText(jsdocNode, sourceLines.join('\\n'));\n    });\n  }\n}, {\n  meta: {\n    fixable: 'whitespace',\n    type: 'layout'\n  },\n  schema: [\n    {\n      enum: ['always'],\n      type: 'string'\n    }\n  ]\n});\n"],"file":"newlineAfterDescription.js"}