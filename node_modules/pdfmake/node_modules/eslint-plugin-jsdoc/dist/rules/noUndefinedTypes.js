"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _jsdoctypeparser = require("jsdoctypeparser");

var _iterateJsdoc = _interopRequireWildcard(require("../iterateJsdoc"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const extraTypes = ['null', 'undefined', 'string', 'boolean', 'object', 'function', 'number', 'NaN', 'Infinity', 'any', '*', 'Array', 'Object', 'RegExp', 'Date', 'Function'];

var _default = (0, _iterateJsdoc.default)(({
  context,
  report,
  sourceCode,
  utils
}) => {
  const scopeManager = sourceCode.scopeManager;
  const globalScope = scopeManager.globalScope;

  const _ref = context.options[0] || {},
        preferredTypesDefined = _ref.preferredTypesDefined,
        _ref$definedTypes = _ref.definedTypes,
        definedTypes = _ref$definedTypes === void 0 ? [] : _ref$definedTypes;

  let definedPreferredTypes = [];

  if (preferredTypesDefined) {
    const preferredTypes = _lodash.default.get(context, 'settings.jsdoc.preferredTypes');

    if (preferredTypes) {
      // Replace `_.values` with `Object.values` when we may start requiring Node 7+
      definedPreferredTypes = _lodash.default.values(preferredTypes).map(preferredType => {
        if (typeof preferredType === 'string') {
          return preferredType;
        }

        if (!preferredType || typeof preferredType !== 'object') {
          return undefined;
        }

        return preferredType.replacement;
      }).filter(preferredType => {
        return preferredType;
      });
    }
  }

  const typedefDeclarations = (0, _lodash.default)(context.getAllComments()).filter(comment => {
    return comment.value.startsWith('*');
  }).map(_iterateJsdoc.parseComment).flatMap(doc => {
    return (doc.tags || []).filter(({
      tag
    }) => {
      return utils.isNamepathDefiningTag(tag);
    });
  }).map(tag => {
    return tag.name;
  }).value();
  const allDefinedTypes = globalScope.variables.map(variable => {
    return variable.name;
  }) // If the file is a module, concat the variables from the module scope.
  .concat( // This covers `commonjs` as well as `node`
  scopeManager.__options.nodejsScope || scopeManager.isModule() ? globalScope.childScopes.reduce((arr, {
    variables
  }) => {
    // Flatten
    arr.push(...variables);
    return arr;
  }, []).map(({
    name
  }) => {
    return name;
  }) : []).concat(extraTypes).concat(typedefDeclarations).concat(definedTypes).concat(definedPreferredTypes);
  const jsdocTags = utils.filterTags(tag => {
    return utils.isTagWithType(tag.tag);
  });
  jsdocTags.forEach(tag => {
    let parsedType;

    try {
      parsedType = (0, _jsdoctypeparser.parse)(tag.type);
    } catch (error) {
      // On syntax error, will be handled by valid-types.
      return;
    }

    (0, _jsdoctypeparser.traverse)(parsedType, ({
      type,
      name
    }) => {
      if (type === 'NAME') {
        if (!allDefinedTypes.includes(name)) {
          report('The type \'' + name + '\' is undefined.', null, tag);
        } else if (!_lodash.default.includes(extraTypes, name)) {
          context.markVariableAsUsed(name);
        }
      }
    });
  });
}, {
  meta: {
    type: 'suggestion'
  }
});

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=noUndefinedTypes.js.map