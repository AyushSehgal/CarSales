{"version":3,"sources":["../../src/rules/validTypes.js"],"names":["asExpression","jsdoc","report","utils","tags","forEach","tag","validTypeParsing","type","error","name","thisNamepath","description","replace","test","thatNamepath","isNamepathTag","passesEmptyNamepathCheck","isTagWithType","meta"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEA,MAAMA,YAAY,GAAG,OAArB;;eAEe,2BAAa,CAAC;AAC3BC,EAAAA,KAD2B;AAE3BC,EAAAA,MAF2B;AAG3BC,EAAAA;AAH2B,CAAD,KAItB;AACJ,MAAI,CAACF,KAAK,CAACG,IAAX,EAAiB;AACf;AACD;;AACDH,EAAAA,KAAK,CAACG,IAAN,CAAWC,OAAX,CAAoBC,GAAD,IAAS;AAC1B,UAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAUC,IAAV,EAAgB;AACvC,UAAI;AACF,oCAAMA,IAAN;AACD,OAFD,CAEE,OAAOC,KAAP,EAAc;AACd,YAAIA,KAAK,CAACC,IAAN,KAAe,aAAnB,EAAkC;AAChCR,UAAAA,MAAM,CAAC,2BAA2BM,IAA5B,EAAkC,IAAlC,EAAwCF,GAAxC,CAAN;AAEA,iBAAO,KAAP;AACD;AACF;;AAED,aAAO,IAAP;AACD,KAZD;;AAcA,QAAIA,GAAG,CAACA,GAAJ,KAAY,SAAhB,EAA2B;AACzB,YAAMK,YAAY,GAAGL,GAAG,CAACM,WAAJ,CAAgBC,OAAhB,CAAwBb,YAAxB,EAAsC,EAAtC,CAArB;;AAEA,UAAI,CAACA,YAAY,CAACc,IAAb,CAAkBR,GAAG,CAACM,WAAtB,CAAD,IAAuC,CAACD,YAA5C,EAA0D;AACxDT,QAAAA,MAAM,CAAC,mDAAmDI,GAAG,CAACM,WAAvD,GAAqE,GAAtE,EAA2E,IAA3E,EAAiFN,GAAjF,CAAN;AAEA;AACD;;AAED,UAAIC,gBAAgB,CAACI,YAAD,CAApB,EAAoC;AAClC,cAAMI,YAAY,GAAGT,GAAG,CAACI,IAAzB;AAEAH,QAAAA,gBAAgB,CAACQ,YAAD,CAAhB;AACD;AACF,KAdD,MAcO,IAAIZ,KAAK,CAACa,aAAN,CAAoBV,GAAG,CAACA,GAAxB,CAAJ,EAAkC;AACvC,UAAIH,KAAK,CAACc,wBAAN,CAA+BX,GAA/B,CAAJ,EAAyC;AACvC;AACD;;AACDC,MAAAA,gBAAgB,CAACD,GAAG,CAACI,IAAL,CAAhB;AACD,KALM,MAKA,IAAIJ,GAAG,CAACE,IAAJ,IAAYL,KAAK,CAACe,aAAN,CAAoBZ,GAAG,CAACA,GAAxB,CAAhB,EAA8C;AACnDC,MAAAA,gBAAgB,CAACD,GAAG,CAACE,IAAL,CAAhB;AACD;AACF,GArCD;AAsCD,CA9Cc,EA8CZ;AACDW,EAAAA,IAAI,EAAE;AACJX,IAAAA,IAAI,EAAE;AADF;AADL,CA9CY,C","sourcesContent":["import {parse} from 'jsdoctypeparser';\nimport iterateJsdoc from '../iterateJsdoc';\n\nconst asExpression = /as\\s+/;\n\nexport default iterateJsdoc(({\n  jsdoc,\n  report,\n  utils\n}) => {\n  if (!jsdoc.tags) {\n    return;\n  }\n  jsdoc.tags.forEach((tag) => {\n    const validTypeParsing = function (type) {\n      try {\n        parse(type);\n      } catch (error) {\n        if (error.name === 'SyntaxError') {\n          report('Syntax error in type: ' + type, null, tag);\n\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    if (tag.tag === 'borrows') {\n      const thisNamepath = tag.description.replace(asExpression, '');\n\n      if (!asExpression.test(tag.description) || !thisNamepath) {\n        report('@borrows must have an \"as\" expression. Found \"' + tag.description + '\"', null, tag);\n\n        return;\n      }\n\n      if (validTypeParsing(thisNamepath)) {\n        const thatNamepath = tag.name;\n\n        validTypeParsing(thatNamepath);\n      }\n    } else if (utils.isNamepathTag(tag.tag)) {\n      if (utils.passesEmptyNamepathCheck(tag)) {\n        return;\n      }\n      validTypeParsing(tag.name);\n    } else if (tag.type && utils.isTagWithType(tag.tag)) {\n      validTypeParsing(tag.type);\n    }\n  });\n}, {\n  meta: {\n    type: 'suggestion'\n  }\n});\n"],"file":"validTypes.js"}