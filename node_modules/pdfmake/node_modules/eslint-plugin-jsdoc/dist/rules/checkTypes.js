"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _jsdoctypeparser = require("jsdoctypeparser");

var _iterateJsdoc = _interopRequireDefault(require("../iterateJsdoc"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const strictNativeTypes = ['undefined', 'null', 'boolean', 'number', 'string', 'object', 'Array', 'Function', 'Date', 'RegExp'];

var _default = (0, _iterateJsdoc.default)(({
  jsdocNode,
  sourceCode,
  report,
  utils,
  context
}) => {
  const jsdocTags = utils.filterTags(tag => {
    return utils.isTagWithType(tag.tag);
  });

  const preferredTypes = _lodash.default.get(context, 'settings.jsdoc.preferredTypes');

  const optionObj = context.options[0];

  const noDefaults = _lodash.default.get(optionObj, 'noDefaults');

  const unifyParentAndChildTypeChecks = _lodash.default.get(optionObj, 'unifyParentAndChildTypeChecks');

  jsdocTags.forEach(jsdocTag => {
    const invalidTypes = [];
    let typeAst;

    try {
      typeAst = (0, _jsdoctypeparser.parse)(jsdocTag.type);
    } catch (error) {
      return;
    }

    const getPreferredTypeInfo = (type, nodeName) => {
      let hasMatchingPreferredType;
      let isGenericMatch;

      if (preferredTypes) {
        const nonparentType = type === 'ANY' || typeAst.type === 'NAME';
        isGenericMatch = _lodash.default.get(preferredTypes, nodeName + '<>') !== undefined && (unifyParentAndChildTypeChecks || !nonparentType);
        hasMatchingPreferredType = _lodash.default.get(preferredTypes, nodeName) !== undefined && (nonparentType || unifyParentAndChildTypeChecks) || isGenericMatch;
      }

      return [hasMatchingPreferredType, isGenericMatch];
    };

    (0, _jsdoctypeparser.traverse)(typeAst, node => {
      const type = node.type,
            name = node.name;

      if (['NAME', 'ANY'].includes(type)) {
        const nodeName = type === 'ANY' ? '*' : name;

        const _getPreferredTypeInfo = getPreferredTypeInfo(type, nodeName),
              _getPreferredTypeInfo2 = _slicedToArray(_getPreferredTypeInfo, 2),
              hasMatchingPreferredType = _getPreferredTypeInfo2[0],
              isGenericMatch = _getPreferredTypeInfo2[1];

        let preferred;

        if (hasMatchingPreferredType) {
          const preferredSetting = preferredTypes[nodeName + (isGenericMatch ? '<>' : '')];

          if (!preferredSetting) {
            invalidTypes.push([nodeName]);
          } else if (typeof preferredSetting === 'string') {
            preferred = preferredSetting;
            invalidTypes.push([nodeName, preferred]);
          } else if (typeof preferredSetting === 'object') {
            preferred = _lodash.default.get(preferredSetting, 'replacement');
            invalidTypes.push([nodeName, preferred, _lodash.default.get(preferredSetting, 'message')]);
          }
        } else if (!noDefaults && type === 'NAME') {
          for (var _i2 = 0, _strictNativeTypes = strictNativeTypes; _i2 < _strictNativeTypes.length; _i2++) {
            const strictNativeType = _strictNativeTypes[_i2];

            if (strictNativeType.toLowerCase() === nodeName.toLowerCase() && strictNativeType !== nodeName && ( // Don't report if user has own map for a strict native type
            !preferredTypes || _lodash.default.get(preferredTypes, strictNativeType) === undefined)) {
              preferred = strictNativeType;
              invalidTypes.push([nodeName, preferred]);
              break;
            }
          }
        }

        if (preferred) {
          if (type === 'ANY') {
            node.type = 'NAME';
          }

          node.name = preferred;
        }
      }
    });

    if (invalidTypes.length) {
      const fixedType = (0, _jsdoctypeparser.publish)(typeAst);
      const tagName = jsdocTag.tag;
      invalidTypes.forEach(([badType, preferredType = '', message]) => {
        const fix = fixer => {
          return fixer.replaceText(jsdocNode, sourceCode.getText(jsdocNode).replace('{' + jsdocTag.type + '}', '{' + fixedType + '}'));
        };

        const tagValue = jsdocTag.name ? ' "' + jsdocTag.name + '"' : '';
        report(message || 'Invalid JSDoc @' + tagName + tagValue + ' type "' + badType + (preferredType ? '"; prefer: "' + preferredType : '') + '".', preferredType ? fix : null, jsdocTag, message ? {
          badType,
          preferredType,
          replacement: preferredType,
          tagName,
          tagValue
        } : null);
      });
    }
  });
}, {
  meta: {
    fixable: 'code',
    type: 'suggestion'
  }
});

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=checkTypes.js.map