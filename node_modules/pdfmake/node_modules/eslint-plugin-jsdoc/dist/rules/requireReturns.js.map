{"version":3,"sources":["../../src/rules/requireReturns.js"],"names":["canSkip","utils","hasATag","isConstructor","isSetter","avoidDocs","report","tagName","getPreferredTagName","tags","getTags","length","tag","missingReturnTag","hasReturnValue","isForceRequireReturn","meta","type"],"mappings":";;;;;;;AAAA;;;;;;;;;;;;AAEA;;;;;;;;;;;AAWA,MAAMA,OAAO,GAAIC,KAAD,IAAW;AACzB,SAAOA,KAAK,CAACC,OAAN,CAAc,CACnB;AACA;AACA;AACA;AACA;AACA,YANmB,EAOnB,SAPmB,EASnB;AACA;AACA,SAXmB,EAYnB,aAZmB,EAcnB;AACA,aAfmB,CAAd,KAiBLD,KAAK,CAACE,aAAN,EAjBK,IAmBL;AACA;AACAF,EAAAA,KAAK,CAACG,QAAN,EArBK,IAsBLH,KAAK,CAACI,SAAN,EAtBF;AAuBD,CAxBD;;eA0Be,2BAAa,CAAC;AAC3BC,EAAAA,MAD2B;AAE3BL,EAAAA;AAF2B,CAAD,KAGtB;AACJ;AACA;AACA,MAAID,OAAO,CAACC,KAAD,CAAX,EAAoB;AAClB;AACD;;AAED,QAAMM,OAAO,GAAGN,KAAK,CAACO,mBAAN,CAA0B,SAA1B,CAAhB;AACA,QAAMC,IAAI,GAAGR,KAAK,CAACS,OAAN,CAAcH,OAAd,CAAb;;AAEA,MAAIE,IAAI,CAACE,MAAL,GAAc,CAAlB,EAAqB;AACnBL,IAAAA,MAAM,CAAC,2BAA2BC,OAA3B,GAAqC,eAAtC,CAAN;AACD,GAZG,CAcJ;;;AAdI,+BAeUE,IAfV;AAAA,QAeGG,GAfH;;AAgBJ,QAAMC,gBAAgB,GAAG,OAAOD,GAAP,KAAe,WAAf,IAA8BA,GAAG,KAAK,IAA/D;;AACA,MAAIC,gBAAgB,KACjBZ,KAAK,CAACa,cAAN,MAA0Bb,KAAK,CAACc,oBAAN,EADT,CAApB,EAEE;AACAT,IAAAA,MAAM,CAAC,oBAAoBC,OAApB,GAA8B,eAA/B,CAAN;AACD;AACF,CAzBc,EAyBZ;AACDS,EAAAA,IAAI,EAAE;AACJC,IAAAA,IAAI,EAAE;AADF;AADL,CAzBY,C","sourcesContent":["import iterateJsdoc from '../iterateJsdoc';\n\n/**\n * We can skip checking for a return value, in case the documentation is inherited\n * or the method is either a constructor or an abstract method.\n *\n * In either of these cases the return value is optional or not defined.\n *\n * @param {*} utils\n *   a reference to the utils which are used to probe if a tag is present or not.\n * @returns {boolean}\n *   true in case deep checking can be skipped; otherwise false.\n */\nconst canSkip = (utils) => {\n  return utils.hasATag([\n    // inheritdoc implies that all documentation is inherited\n    // see http://usejsdoc.org/tags-inheritdoc.html\n    //\n    // Abstract methods are by definition incomplete,\n    // so it is not an error if it declares a return value but does not implement it.\n    'abstract',\n    'virtual',\n\n    // Constructors do not have a return value by definition (http://usejsdoc.org/tags-class.html)\n    // So we can bail out here, too.\n    'class',\n    'constructor',\n\n    // This seems to imply a class as well\n    'interface'\n  ]) ||\n    utils.isConstructor() ||\n\n    // Though ESLint avoided getters: https://github.com/eslint/eslint/blob/master/lib/rules/valid-jsdoc.js#L435\n    //  ... getters seem that they should, unlike setters, always return:\n    utils.isSetter() ||\n    utils.avoidDocs();\n};\n\nexport default iterateJsdoc(({\n  report,\n  utils\n}) => {\n  // A preflight check. We do not need to run a deep check\n  // in case the @returns comment is optional or undefined.\n  if (canSkip(utils)) {\n    return;\n  }\n\n  const tagName = utils.getPreferredTagName('returns');\n  const tags = utils.getTags(tagName);\n\n  if (tags.length > 1) {\n    report('Found more than one  @' + tagName + ' declaration.');\n  }\n\n  // In case the code returns something, we expect a return value in JSDoc.\n  const [tag] = tags;\n  const missingReturnTag = typeof tag === 'undefined' || tag === null;\n  if (missingReturnTag &&\n    (utils.hasReturnValue() || utils.isForceRequireReturn())\n  ) {\n    report('Missing JSDoc @' + tagName + ' declaration.');\n  }\n}, {\n  meta: {\n    type: 'suggestion'\n  }\n});\n"],"file":"requireReturns.js"}