"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.parseComment = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _commentParser = _interopRequireDefault(require("comment-parser"));

var _jsdocUtils = _interopRequireDefault(require("./jsdocUtils"));

var _getJSDocComment = _interopRequireDefault(require("./eslint/getJSDocComment"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const parseComment = (commentNode, indent) => {
  // Preserve JSDoc block start/end indentation.
  return (0, _commentParser.default)(indent + '/*' + commentNode.value + indent + '*/', {
    // @see https://github.com/yavorskiy/comment-parser/issues/21
    parsers: [_commentParser.default.PARSERS.parse_tag, _commentParser.default.PARSERS.parse_type, (str, data) => {
      if (['return', 'returns', 'throws', 'exception'].includes(data.tag)) {
        return null;
      }

      return _commentParser.default.PARSERS.parse_name(str, data);
    }, _commentParser.default.PARSERS.parse_description]
  })[0] || {};
};

exports.parseComment = parseComment;

const curryUtils = (node, jsdoc, tagNamePreference, exampleCodeRegex, rejectExampleCodeRegex, additionalTagNames, baseConfig, configFile, captionRequired, matchingFileName, eslintrcForExamples, allowInlineConfig, allowEmptyNamepaths, reportUnusedDisableDirectives, noDefaultExampleRules, overrideReplacesDocs, implementsReplacesDocs, augmentsExtendsReplacesDocs, allowOverrideWithoutParam, allowImplementsWithoutParam, allowAugmentsExtendsWithoutParam, checkSeesForNamepaths, forceRequireReturn, avoidExampleOnConstructors, ancestors, sourceCode, context) => {
  const utils = {};

  utils.getFunctionParameterNames = () => {
    return _jsdocUtils.default.getFunctionParameterNames(node);
  };

  utils.getFunctionSourceCode = () => {
    return sourceCode.getText(node);
  };

  utils.isConstructor = () => {
    return node.parent && node.parent.kind === 'constructor';
  };

  utils.isSetter = () => {
    return node.parent.kind === 'set';
  };

  utils.getJsdocParameterNamesDeep = () => {
    return _jsdocUtils.default.getJsdocParameterNamesDeep(jsdoc, utils.getPreferredTagName('param'));
  };

  utils.getJsdocParameterNames = () => {
    return _jsdocUtils.default.getJsdocParameterNames(jsdoc, utils.getPreferredTagName('param'));
  };

  utils.getPreferredTagName = name => {
    return _jsdocUtils.default.getPreferredTagName(name, tagNamePreference);
  };

  utils.getExampleCodeRegex = () => {
    return exampleCodeRegex;
  };

  utils.getRejectExampleCodeRegex = () => {
    return rejectExampleCodeRegex;
  };

  utils.getMatchingFileName = () => {
    return matchingFileName;
  };

  utils.isValidTag = name => {
    return _jsdocUtils.default.isValidTag(name, additionalTagNames);
  };

  utils.hasATag = name => {
    return _jsdocUtils.default.hasATag(jsdoc, name);
  };

  utils.hasTag = name => {
    return _jsdocUtils.default.hasTag(jsdoc, name);
  };

  utils.useEslintrcForExamples = () => {
    return eslintrcForExamples;
  };

  utils.allowInlineConfig = () => {
    return allowInlineConfig;
  };

  utils.reportUnusedDisableDirectives = () => {
    return reportUnusedDisableDirectives;
  };

  utils.hasNoDefaultExampleRules = () => {
    return noDefaultExampleRules;
  };

  utils.getBaseConfig = () => {
    return baseConfig;
  };

  utils.getConfigFile = () => {
    return configFile;
  };

  utils.isCaptionRequired = () => {
    return captionRequired;
  }; // These settings are deprecated and may be removed in the future along with this method.


  utils.avoidDocsParamOnly = () => {
    // These three checks are all for deprecated settings and may be removed in the future
    // When settings.jsdoc.allowOverrideWithoutParam is true, override implies that all documentation is inherited.
    if ((utils.hasTag('override') || utils.classHasTag('override')) && allowOverrideWithoutParam !== false) {
      return true;
    } // When settings.jsdoc.allowImplementsWithoutParam is true, implements implies that all documentation is inherited.
    // See https://github.com/gajus/eslint-plugin-jsdoc/issues/100


    if ((utils.hasTag('implements') || utils.classHasTag('implements')) && allowImplementsWithoutParam !== false) {
      return true;
    } // When settings.jsdoc.allowAugmentsExtendsWithoutParam is true, augments or extends implies that all documentation is inherited.


    if ((utils.hasTag('augments') || utils.hasTag('extends') || utils.classHasTag('augments') || utils.classHasTag('extends')) && allowAugmentsExtendsWithoutParam) {
      return true;
    }

    return false;
  };

  utils.avoidDocs = param => {
    return param && utils.avoidDocsParamOnly() || // inheritdoc implies that all documentation is inherited; see http://usejsdoc.org/tags-inheritdoc.html
    utils.hasTag('inheritdoc') || // After deprecation, the `param` parameter can be removed, but for now,
    //  don't default for `param` as it may have its own explicit settings to the contrary
    (param && overrideReplacesDocs || !param && overrideReplacesDocs !== false) && (utils.hasTag('override') || utils.classHasTag('override')) || (param && implementsReplacesDocs || !param && implementsReplacesDocs !== false) && (utils.hasTag('implements') || utils.classHasTag('implements')) || augmentsExtendsReplacesDocs && (utils.hasATag(['augments', 'extends']) || utils.classHasTag('augments') || utils.classHasTag('extends'));
  };

  utils.isNamepathDefiningTag = tagName => {
    return _jsdocUtils.default.isNamepathDefiningTag(tagName);
  };

  utils.isNamepathTag = tagName => {
    return _jsdocUtils.default.isNamepathTag(tagName, checkSeesForNamepaths);
  };

  utils.isTagWithType = tagName => {
    return _jsdocUtils.default.isTagWithType(tagName);
  };

  utils.avoidExampleOnConstructors = () => {
    return avoidExampleOnConstructors;
  };

  utils.passesEmptyNamepathCheck = tag => {
    return !tag.name && allowEmptyNamepaths && _jsdocUtils.default.isPotentiallyEmptyNamepathTag(tag.tag);
  };

  utils.hasDefinedTypeReturnTag = tag => {
    return _jsdocUtils.default.hasDefinedTypeReturnTag(tag);
  };

  utils.hasReturnValue = () => {
    return _jsdocUtils.default.hasReturnValue(node, context);
  };

  utils.getTags = tagName => {
    return utils.filterTags(item => {
      return item.tag === tagName;
    });
  };

  utils.isForceRequireReturn = () => {
    return forceRequireReturn;
  };

  utils.filterTags = filter => {
    return (jsdoc.tags || []).filter(filter);
  };

  utils.getClassNode = () => {
    const greatGrandParent = ancestors.slice(-3)[0];
    const greatGrandParentValue = greatGrandParent && sourceCode.getFirstToken(greatGrandParent).value;

    if (greatGrandParentValue === 'class') {
      return greatGrandParent;
    }

    return false;
  };

  utils.classHasTag = tagName => {
    const classNode = utils.getClassNode();
    const classJsdocNode = (0, _getJSDocComment.default)(sourceCode, classNode);

    if (classJsdocNode) {
      const indent = _lodash.default.repeat(' ', classJsdocNode.loc.start.column);

      const classJsdoc = parseComment(classJsdocNode, indent);

      if (_jsdocUtils.default.hasTag(classJsdoc, tagName)) {
        return true;
      }
    }

    return false;
  };

  utils.forEachTag = (tagName, arrayHandler) => {
    const matchingJsdocTags = _lodash.default.filter(jsdoc.tags || [], {
      tag: tagName
    });

    matchingJsdocTags.forEach(matchingJsdocTag => {
      arrayHandler(matchingJsdocTag);
    });
  };

  return utils;
};

var _default = (iterator, opts = {}) => {
  return {
    /**
     * The entrypoint for the JSDoc rule.
     *
     * @param {*} context
     *   a reference to the context which hold all important information
     *   like settings and the sourcecode to check.
     * @returns {Object}
     *   a list with parser callback function.
     */
    create(context) {
      const sourceCode = context.getSourceCode(); // All rules

      const ignorePrivate = Boolean(_lodash.default.get(context, 'settings.jsdoc.ignorePrivate')); // `check-tag-names` and many require/param rules

      const tagNamePreference = _lodash.default.get(context, 'settings.jsdoc.tagNamePreference') || {}; // `check-tag-names` only

      const additionalTagNames = _lodash.default.get(context, 'settings.jsdoc.additionalTagNames') || {}; // `check-examples` only

      const exampleCodeRegex = _lodash.default.get(context, 'settings.jsdoc.exampleCodeRegex') || null;
      const rejectExampleCodeRegex = _lodash.default.get(context, 'settings.jsdoc.rejectExampleCodeRegex') || null;
      const matchingFileName = _lodash.default.get(context, 'settings.jsdoc.matchingFileName') || null;
      const baseConfig = _lodash.default.get(context, 'settings.jsdoc.baseConfig') || {};

      const configFile = _lodash.default.get(context, 'settings.jsdoc.configFile');

      const eslintrcForExamples = _lodash.default.get(context, 'settings.jsdoc.eslintrcForExamples') !== false;
      const allowInlineConfig = _lodash.default.get(context, 'settings.jsdoc.allowInlineConfig') !== false;
      const reportUnusedDisableDirectives = _lodash.default.get(context, 'settings.jsdoc.reportUnusedDisableDirectives') !== false;
      const captionRequired = Boolean(_lodash.default.get(context, 'settings.jsdoc.captionRequired'));
      const noDefaultExampleRules = Boolean(_lodash.default.get(context, 'settings.jsdoc.noDefaultExampleRules')); // `require-param`, `require-description`, `require-example`, `require-returns`

      const overrideReplacesDocs = _lodash.default.get(context, 'settings.jsdoc.overrideReplacesDocs');

      const implementsReplacesDocs = _lodash.default.get(context, 'settings.jsdoc.implementsReplacesDocs');

      const augmentsExtendsReplacesDocs = _lodash.default.get(context, 'settings.jsdoc.augmentsExtendsReplacesDocs'); // `require-param` only (deprecated)


      const allowOverrideWithoutParam = _lodash.default.get(context, 'settings.jsdoc.allowOverrideWithoutParam');

      const allowImplementsWithoutParam = _lodash.default.get(context, 'settings.jsdoc.allowImplementsWithoutParam');

      const allowAugmentsExtendsWithoutParam = _lodash.default.get(context, 'settings.jsdoc.allowAugmentsExtendsWithoutParam'); // `valid-types` only


      const allowEmptyNamepaths = _lodash.default.get(context, 'settings.jsdoc.allowEmptyNamepaths') !== false;
      const checkSeesForNamepaths = Boolean(_lodash.default.get(context, 'settings.jsdoc.checkSeesForNamepaths')); // `require-returns` only

      const forceRequireReturn = Boolean(_lodash.default.get(context, 'settings.jsdoc.forceRequireReturn')); // `require-example` only

      const avoidExampleOnConstructors = Boolean(_lodash.default.get(context, 'settings.jsdoc.avoidExampleOnConstructors'));

      const checkJsdoc = node => {
        const jsdocNode = (0, _getJSDocComment.default)(sourceCode, node);

        if (!jsdocNode) {
          return;
        }

        const ancestors = context.getAncestors();

        const indent = _lodash.default.repeat(' ', jsdocNode.loc.start.column);

        const jsdoc = parseComment(jsdocNode, indent);

        const report = (message, fixer = null, jsdocLoc = null, data = null) => {
          let loc;

          if (jsdocLoc) {
            const lineNumber = jsdocNode.loc.start.line + jsdocLoc.line;
            loc = {
              end: {
                line: lineNumber
              },
              start: {
                line: lineNumber
              }
            };

            if (jsdocLoc.column) {
              const colNumber = jsdocNode.loc.start.column + jsdocLoc.column;
              loc.end.column = colNumber;
              loc.start.column = colNumber;
            }
          }

          if (fixer === null) {
            context.report({
              data,
              loc,
              message,
              node: jsdocNode
            });
          } else {
            context.report({
              data,
              fix: fixer,
              loc,
              message,
              node: jsdocNode
            });
          }
        };

        const utils = curryUtils(node, jsdoc, tagNamePreference, exampleCodeRegex, rejectExampleCodeRegex, additionalTagNames, baseConfig, configFile, captionRequired, matchingFileName, eslintrcForExamples, allowInlineConfig, allowEmptyNamepaths, reportUnusedDisableDirectives, noDefaultExampleRules, overrideReplacesDocs, implementsReplacesDocs, augmentsExtendsReplacesDocs, allowOverrideWithoutParam, allowImplementsWithoutParam, allowAugmentsExtendsWithoutParam, checkSeesForNamepaths, forceRequireReturn, avoidExampleOnConstructors, ancestors, sourceCode);

        if (ignorePrivate && utils.hasTag('private')) {
          return;
        }

        iterator({
          context,
          indent,
          jsdoc,
          jsdocNode,
          node,
          report,
          sourceCode,
          utils
        });
      };

      let contexts = opts.returns;

      if (typeof opts.returns === 'function') {
        contexts = opts.returns(context, sourceCode, checkJsdoc);
      }

      if (Array.isArray(contexts)) {
        return contexts.reduce((obj, prop) => {
          obj[prop] = checkJsdoc;
          return obj;
        }, {});
      } else if (contexts) {
        return contexts;
      }

      return {
        ArrowFunctionExpression: checkJsdoc,
        FunctionDeclaration: checkJsdoc,
        FunctionExpression: checkJsdoc
      };
    },

    meta: opts.meta
  };
};

exports.default = _default;
//# sourceMappingURL=iterateJsdoc.js.map