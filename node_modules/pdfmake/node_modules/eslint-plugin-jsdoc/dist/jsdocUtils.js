"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _tagNames = _interopRequireDefault(require("./tagNames"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getFunctionParameterNames = functionNode => {
  return _lodash.default.map(functionNode.params, param => {
    if (_lodash.default.has(param, 'name')) {
      return param.name;
    }

    if (_lodash.default.has(param, 'left.name')) {
      return param.left.name;
    }

    if (param.type === 'ObjectPattern' || _lodash.default.get(param, 'left.type') === 'ObjectPattern') {
      return '<ObjectPattern>';
    }

    if (param.type === 'ArrayPattern' || _lodash.default.get(param, 'left.type') === 'ArrayPattern') {
      return '<ArrayPattern>';
    }

    if (param.type === 'RestElement') {
      return param.argument.name;
    }

    throw new Error('Unsupported function signature format.');
  });
};
/**
 * Gets all parameter names, including those that refer to a path, e.g. "@param foo; @param foo.bar".
 */


const getJsdocParameterNamesDeep = (jsdoc, targetTagName) => {
  let jsdocParameterNames;
  jsdocParameterNames = _lodash.default.filter(jsdoc.tags, {
    tag: targetTagName
  });
  jsdocParameterNames = _lodash.default.map(jsdocParameterNames, 'name');
  return jsdocParameterNames;
};

const getJsdocParameterNames = (jsdoc, targetTagName) => {
  let jsdocParameterNames;
  jsdocParameterNames = getJsdocParameterNamesDeep(jsdoc, targetTagName);
  jsdocParameterNames = jsdocParameterNames.filter(name => {
    return !name.includes('.');
  });
  return jsdocParameterNames;
};

const getPreferredTagName = (name, tagPreference = {}) => {
  if (_lodash.default.values(tagPreference).includes(name)) {
    return name;
  }

  const preferredTagName = _lodash.default.findKey(_tagNames.default, aliases => {
    return aliases.includes(name);
  });

  if (preferredTagName) {
    return preferredTagName;
  }

  return _lodash.default.has(tagPreference, name) ? tagPreference[name] : name;
};

const isValidTag = (name, additionalTagNames) => {
  const validTagNames = _lodash.default.keys(_tagNames.default).concat(_lodash.default.flatten(_lodash.default.values(_tagNames.default)));

  const additionalTags = additionalTagNames.customTags || [];
  const allTags = validTagNames.concat(additionalTags);
  return allTags.includes(name);
};

const hasTag = (jsdoc, targetTagName) => {
  const targetTagLower = targetTagName.toLowerCase();
  return _lodash.default.some(jsdoc.tags, doc => {
    return doc.tag.toLowerCase() === targetTagLower;
  });
};

const hasATag = (jsdoc, targetTagNames) => {
  return targetTagNames.some(targetTagName => {
    return hasTag(jsdoc, targetTagName);
  });
};
/**
 * Checks if the JSDoc comment declares a return value.
 *
 * @param {JsDocTag} tag
 *   the tag which should be checked.
 * @returns {boolean}
 *   true in case a return value is declared; otherwise false.
 */


const hasDefinedTypeReturnTag = tag => {
  // The function should not continue in the event @returns is not defined...
  if (typeof tag === 'undefined' || tag === null) {
    return false;
  } // .. same applies if it declares `@returns {undefined}` or `@returns {void}`


  const tagType = tag.type.trim();

  if (tagType === 'undefined' || tagType === 'void') {
    return false;
  } // In any other case, something must be returned, and
  // a return statement is expected


  return true;
};

const namepathDefiningTags = [// NOT USEFUL WITHOUT NAMEPATH
'external', 'host', 'name', 'typedef', // MAY BE USEFUL WITHOUT NAMEPATH
'event', // MAY BE USEFUL WITHOUT NAMEPATH (OR
//  BLOCK CAN USE NAMEPATH FROM ELSEWHERE)
'class', 'constructor', 'constant', 'const', 'callback', 'function', 'func', 'method', 'interface', 'member', 'var', 'mixin', 'namespace'];
const namepathPointingTags = [// NOT USEFUL WITHOUT NAMEPATH
'alias', 'augments', 'extends', // `borrows` has a different format, however, so needs special parsing
'borrows', 'lends', 'memberof', 'memberof!', 'mixes', 'this', // MAY BE USEFUL WITHOUT NAMEPATH
'emits', 'fires', 'listens'];

const isNamepathDefiningTag = tagName => {
  return namepathDefiningTags.includes(tagName);
};

const isNamepathPointingTag = (tagName, checkSeesForNamepaths) => {
  return namepathPointingTags.includes(tagName) || tagName === 'see' && checkSeesForNamepaths;
};

const isNamepathTag = (tagName, checkSeesForNamepaths) => {
  return isNamepathDefiningTag(tagName) || isNamepathPointingTag(tagName, checkSeesForNamepaths);
};

const potentiallyEmptyNamepathTags = [// These may serve some minor purpose when empty or
//  their namepath can be expressed elsewhere on the block
'event', 'callback', 'class', 'constructor', 'constant', 'const', 'function', 'func', 'method', 'interface', 'member', 'var', 'mixin', 'namespace', 'listens', 'fires', 'emits'];

const isPotentiallyEmptyNamepathTag = tag => {
  return potentiallyEmptyNamepathTags.includes(tag);
};

let tagsWithTypes = ['class', 'constant', 'enum', 'implements', 'member', 'module', 'namespace', 'param', 'property', 'returns', 'throws', 'type', 'typedef', 'yields'];
const closureTagsWithTypes = ['package', 'private', 'protected', 'public', 'static'];
const tagsWithTypesAliases = ['constructor', 'const', 'var', 'arg', 'argument', 'prop', 'return', 'exception', 'yield'];
tagsWithTypes = tagsWithTypes.concat(tagsWithTypesAliases, closureTagsWithTypes);

const isTagWithType = tagName => {
  return tagsWithTypes.includes(tagName);
};

const LOOP_STATEMENTS = ['WhileStatement', 'DoWhileStatement', 'ForStatement', 'ForInStatement', 'ForOfStatement'];
const STATEMENTS_WITH_CHILDREN = ['@loop', 'SwitchStatement', 'IfStatement', 'BlockStatement', 'TryStatement'];
const RETURNFREE_STATEMENTS = ['VariableDeclaration', 'ThrowStatement', 'FunctionDeclaration', 'BreakStatement', 'ContinueStatement', 'LabeledStatement', 'DebuggerStatement', 'EmptyStatement', 'WithStatement', 'ThrowStatement', 'ExpressionStatement'];
const ENTRY_POINTS = ['FunctionDeclaration', 'ArrowFunctionExpression', 'FunctionExpression'];
/* eslint-disable sort-keys */

const lookupTable = {
  ReturnStatement: {
    is(node) {
      return node.type === 'ReturnStatement';
    },

    check(node) {
      if (!lookupTable.ReturnStatement.is(node)) {
        return false;
      } // A return without any arguments just exits the function
      // and is typically not documented at all in jsdoc.


      if (node.argument === null) {
        return false;
      }

      return true;
    }

  },
  IfStatement: {
    is(node) {
      return node.type === 'IfStatement';
    },

    check(node) {
      if (!lookupTable.IfStatement.is(node)) {
        return false;
      }

      if (lookupTable['@default'].check(node.consequent)) {
        return true;
      }

      if (node.alternate && lookupTable['@default'].check(node.alternate)) {
        return true;
      }

      return false;
    }

  },
  '@loop': {
    is(node) {
      return LOOP_STATEMENTS.includes(node.type);
    },

    check(node) {
      return lookupTable['@default'].check(node.body);
    }

  },
  SwitchStatement: {
    is(node) {
      return node.type === 'SwitchStatement';
    },

    check(node) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = node.cases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          const item = _step.value;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = item.consequent[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              const statement = _step2.value;

              if (lookupTable['@default'].check(statement)) {
                return true;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return false;
    }

  },
  TryStatement: {
    is(node) {
      return node.type === 'TryStatement';
    },

    check(node) {
      if (!lookupTable.TryStatement.is(node)) {
        return false;
      }

      if (lookupTable.BlockStatement.check(node.block)) {
        return true;
      }

      if (node.handler && node.handler.block) {
        if (lookupTable['@default'].check(node)) {
          return true;
        }
      }

      if (lookupTable.BlockStatement.check(node.finalizer)) {
        return true;
      }

      return false;
    }

  },
  BlockStatement: {
    is(node) {
      return node.type === 'BlockStatement';
    },

    check(node, context) {
      // E.g. the catch block statement is optional.
      if (typeof node === 'undefined' || node === null) {
        return false;
      }

      if (!lookupTable.BlockStatement.is(node)) {
        return false;
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = node.body[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          const item = _step3.value;

          if (lookupTable['@default'].check(item, context)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return false;
    }

  },
  FunctionExpression: {
    is(node) {
      return node.type === 'FunctionExpression';
    },

    check(node, context) {
      return node.async || lookupTable.BlockStatement.check(node.body, context);
    }

  },
  ArrowFunctionExpression: {
    is(node) {
      return node.type === 'ArrowFunctionExpression';
    },

    check(node, context) {
      // An expression always has a return value.
      return node.expression || node.async || lookupTable.BlockStatement.check(node.body, context);
    }

  },
  FunctionDeclaration: {
    is(node) {
      return node.type === 'FunctionDeclaration';
    },

    check(node, context) {
      return node.async || lookupTable.BlockStatement.check(node.body, context);
    }

  },
  '@default': {
    check(node, context) {
      // In case it is a `ReturnStatement`, we found what we were looking for
      if (lookupTable.ReturnStatement.is(node)) {
        return lookupTable.ReturnStatement.check(node, context);
      } // In case the element has children, we need to traverse them.
      // Examples are BlockStatement, Choices, TryStatement, Loops, ...


      for (var _i = 0, _STATEMENTS_WITH_CHIL = STATEMENTS_WITH_CHILDREN; _i < _STATEMENTS_WITH_CHIL.length; _i++) {
        const item = _STATEMENTS_WITH_CHIL[_i];

        if (lookupTable[item].is(node)) {
          return lookupTable[item].check(node, context);
        }
      } // Everything else cannot return anything.


      if (RETURNFREE_STATEMENTS.includes(node.type)) {
        return false;
      } // If we end up here, we stumbled upon an unknown elements
      // Most likely it is enough to add it to the blacklist.
      //
      // throw new Error('Unknown node type: ' + node.type);


      return false;
    }

  }
};
/**
 * Checks if the source code returns a return value.
 * It traverses the parsed source code and returns as
 * soon as it stumbles upon the first return statement.
 *
 * @param {Object} node
 *   the node which should be checked.
 * @returns {boolean}
 *   true in case the code returns a return value
 */

const hasReturnValue = (node, context) => {
  // Loop through all of our entry points
  for (var _i2 = 0, _ENTRY_POINTS = ENTRY_POINTS; _i2 < _ENTRY_POINTS.length; _i2++) {
    const item = _ENTRY_POINTS[_i2];

    if (lookupTable[item].is(node)) {
      return lookupTable[item].check(node, context);
    }
  }

  throw new Error('Unknown element ' + node.type);
};
/** @param {string} tag */

/*
const isInlineTag = (tag) => {
  return /^(@link|@linkcode|@linkplain|@tutorial) /.test(tag);
};
*/


var _default = {
  getFunctionParameterNames,
  getJsdocParameterNames,
  getJsdocParameterNamesDeep,
  getPreferredTagName,
  hasATag,
  hasDefinedTypeReturnTag,
  hasReturnValue,
  hasTag,
  isNamepathDefiningTag,
  isNamepathTag,
  isPotentiallyEmptyNamepathTag,
  isTagWithType,
  isValidTag
};
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=jsdocUtils.js.map