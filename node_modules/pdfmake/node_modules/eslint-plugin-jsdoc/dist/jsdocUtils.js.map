{"version":3,"sources":["../src/jsdocUtils.js"],"names":["getFunctionParameterNames","functionNode","_","map","params","param","has","name","left","type","get","argument","Error","getJsdocParameterNamesDeep","jsdoc","targetTagName","jsdocParameterNames","filter","tags","tag","getJsdocParameterNames","includes","getPreferredTagName","tagPreference","values","preferredTagName","findKey","tagNames","aliases","isValidTag","additionalTagNames","validTagNames","keys","concat","flatten","additionalTags","customTags","allTags","hasTag","targetTagLower","toLowerCase","some","doc","hasATag","targetTagNames","hasDefinedTypeReturnTag","tagType","trim","namepathDefiningTags","namepathPointingTags","isNamepathDefiningTag","tagName","isNamepathPointingTag","checkSeesForNamepaths","isNamepathTag","potentiallyEmptyNamepathTags","isPotentiallyEmptyNamepathTag","tagsWithTypes","closureTagsWithTypes","tagsWithTypesAliases","isTagWithType","LOOP_STATEMENTS","STATEMENTS_WITH_CHILDREN","RETURNFREE_STATEMENTS","ENTRY_POINTS","lookupTable","ReturnStatement","is","node","check","IfStatement","consequent","alternate","body","SwitchStatement","cases","item","statement","TryStatement","BlockStatement","block","handler","finalizer","context","FunctionExpression","async","ArrowFunctionExpression","expression","FunctionDeclaration","hasReturnValue"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport tagNames from './tagNames';\n\nconst getFunctionParameterNames = (functionNode : Object) : Array<string> => {\n  return _.map(functionNode.params, (param) => {\n    if (_.has(param, 'name')) {\n      return param.name;\n    }\n\n    if (_.has(param, 'left.name')) {\n      return param.left.name;\n    }\n\n    if (param.type === 'ObjectPattern' || _.get(param, 'left.type') === 'ObjectPattern') {\n      return '<ObjectPattern>';\n    }\n\n    if (param.type === 'ArrayPattern' || _.get(param, 'left.type') === 'ArrayPattern') {\n      return '<ArrayPattern>';\n    }\n\n    if (param.type === 'RestElement') {\n      return param.argument.name;\n    }\n\n    throw new Error('Unsupported function signature format.');\n  });\n};\n\n/**\n * Gets all parameter names, including those that refer to a path, e.g. \"@param foo; @param foo.bar\".\n */\nconst getJsdocParameterNamesDeep = (jsdoc : Object, targetTagName : string) : Array<string> => {\n  let jsdocParameterNames;\n\n  jsdocParameterNames = _.filter(jsdoc.tags, {\n    tag: targetTagName\n  });\n\n  jsdocParameterNames = _.map(jsdocParameterNames, 'name');\n\n  return jsdocParameterNames;\n};\n\nconst getJsdocParameterNames = (jsdoc : Object, targetTagName : string) : Array<string> => {\n  let jsdocParameterNames;\n\n  jsdocParameterNames = getJsdocParameterNamesDeep(jsdoc, targetTagName);\n\n  jsdocParameterNames = jsdocParameterNames.filter((name) => {\n    return !name.includes('.');\n  });\n\n  return jsdocParameterNames;\n};\n\nconst getPreferredTagName = (name : string, tagPreference : Object = {}) : string => {\n  if (_.values(tagPreference).includes(name)) {\n    return name;\n  }\n\n  const preferredTagName = _.findKey(tagNames, (aliases) => {\n    return aliases.includes(name);\n  });\n\n  if (preferredTagName) {\n    return preferredTagName;\n  }\n\n  return _.has(tagPreference, name) ? tagPreference[name] : name;\n};\n\nconst isValidTag = (name : string, additionalTagNames : Object) : boolean => {\n  const validTagNames = _.keys(tagNames).concat(_.flatten(_.values(tagNames)));\n  const additionalTags = additionalTagNames.customTags || [];\n  const allTags = validTagNames.concat(additionalTags);\n\n  return allTags.includes(name);\n};\n\nconst hasTag = (jsdoc : Object, targetTagName : string) : boolean => {\n  const targetTagLower = targetTagName.toLowerCase();\n\n  return _.some(jsdoc.tags, (doc : Object) => {\n    return doc.tag.toLowerCase() === targetTagLower;\n  });\n};\n\nconst hasATag = (jsdoc : Object, targetTagNames : Array) : boolean => {\n  return targetTagNames.some((targetTagName) => {\n    return hasTag(jsdoc, targetTagName);\n  });\n};\n\n/**\n * Checks if the JSDoc comment declares a return value.\n *\n * @param {JsDocTag} tag\n *   the tag which should be checked.\n * @returns {boolean}\n *   true in case a return value is declared; otherwise false.\n */\nconst hasDefinedTypeReturnTag = (tag) => {\n  // The function should not continue in the event @returns is not defined...\n  if (typeof tag === 'undefined' || tag === null) {\n    return false;\n  }\n\n  // .. same applies if it declares `@returns {undefined}` or `@returns {void}`\n  const tagType = tag.type.trim();\n  if (tagType === 'undefined' || tagType === 'void') {\n    return false;\n  }\n\n  // In any other case, something must be returned, and\n  // a return statement is expected\n  return true;\n};\n\nconst namepathDefiningTags = [\n  // NOT USEFUL WITHOUT NAMEPATH\n  'external', 'host',\n  'name',\n  'typedef',\n\n  // MAY BE USEFUL WITHOUT NAMEPATH\n  'event',\n\n  // MAY BE USEFUL WITHOUT NAMEPATH (OR\n  //  BLOCK CAN USE NAMEPATH FROM ELSEWHERE)\n  'class', 'constructor',\n  'constant', 'const',\n  'callback',\n  'function', 'func', 'method',\n  'interface',\n  'member', 'var',\n  'mixin',\n  'namespace'\n];\n\nconst namepathPointingTags = [\n  // NOT USEFUL WITHOUT NAMEPATH\n  'alias',\n  'augments', 'extends',\n\n  // `borrows` has a different format, however, so needs special parsing\n  'borrows',\n  'lends',\n  'memberof',\n  'memberof!',\n  'mixes',\n  'this',\n\n  // MAY BE USEFUL WITHOUT NAMEPATH\n  'emits',\n  'fires',\n  'listens'\n];\n\nconst isNamepathDefiningTag = (tagName) => {\n  return namepathDefiningTags.includes(tagName);\n};\n\nconst isNamepathPointingTag = (tagName, checkSeesForNamepaths) => {\n  return namepathPointingTags.includes(tagName) ||\n    tagName === 'see' && checkSeesForNamepaths;\n};\n\nconst isNamepathTag = (tagName, checkSeesForNamepaths) => {\n  return isNamepathDefiningTag(tagName) ||\n    isNamepathPointingTag(tagName, checkSeesForNamepaths);\n};\n\nconst potentiallyEmptyNamepathTags = [\n  // These may serve some minor purpose when empty or\n  //  their namepath can be expressed elsewhere on the block\n  'event',\n  'callback',\n  'class', 'constructor',\n  'constant', 'const',\n  'function', 'func', 'method',\n  'interface',\n  'member', 'var',\n  'mixin',\n  'namespace',\n  'listens', 'fires', 'emits'\n];\n\nconst isPotentiallyEmptyNamepathTag = (tag) => {\n  return potentiallyEmptyNamepathTags.includes(tag);\n};\n\nlet tagsWithTypes = [\n  'class',\n  'constant',\n  'enum',\n  'implements',\n  'member',\n  'module',\n  'namespace',\n  'param',\n  'property',\n  'returns',\n  'throws',\n  'type',\n  'typedef',\n  'yields'\n];\n\nconst closureTagsWithTypes = [\n  'package', 'private', 'protected', 'public', 'static'\n];\n\nconst tagsWithTypesAliases = [\n  'constructor',\n  'const',\n  'var',\n  'arg',\n  'argument',\n  'prop',\n  'return',\n  'exception',\n  'yield'\n];\n\ntagsWithTypes = tagsWithTypes.concat(tagsWithTypesAliases, closureTagsWithTypes);\n\nconst isTagWithType = (tagName) => {\n  return tagsWithTypes.includes(tagName);\n};\n\nconst LOOP_STATEMENTS = ['WhileStatement', 'DoWhileStatement', 'ForStatement', 'ForInStatement', 'ForOfStatement'];\n\nconst STATEMENTS_WITH_CHILDREN = [\n  '@loop',\n  'SwitchStatement',\n  'IfStatement',\n  'BlockStatement',\n  'TryStatement'\n];\n\nconst RETURNFREE_STATEMENTS = [\n  'VariableDeclaration',\n  'ThrowStatement',\n  'FunctionDeclaration',\n  'BreakStatement',\n  'ContinueStatement',\n  'LabeledStatement',\n  'DebuggerStatement',\n  'EmptyStatement',\n  'WithStatement',\n  'ThrowStatement',\n  'ExpressionStatement'\n];\n\nconst ENTRY_POINTS = ['FunctionDeclaration', 'ArrowFunctionExpression', 'FunctionExpression'];\n\n/* eslint-disable sort-keys */\nconst lookupTable = {\n  ReturnStatement: {\n    is (node) {\n      return node.type === 'ReturnStatement';\n    },\n    check (node) {\n      if (!lookupTable.ReturnStatement.is(node)) {\n        return false;\n      }\n\n      // A return without any arguments just exits the function\n      // and is typically not documented at all in jsdoc.\n      if (node.argument === null) {\n        return false;\n      }\n\n      return true;\n    }\n  },\n  IfStatement: {\n    is (node) {\n      return node.type === 'IfStatement';\n    },\n    check (node) {\n      if (!lookupTable.IfStatement.is(node)) {\n        return false;\n      }\n\n      if (lookupTable['@default'].check(node.consequent)) {\n        return true;\n      }\n\n      if (node.alternate && lookupTable['@default'].check(node.alternate)) {\n        return true;\n      }\n\n      return false;\n    }\n  },\n  '@loop': {\n    is (node) {\n      return LOOP_STATEMENTS.includes(node.type);\n    },\n    check (node) {\n      return lookupTable['@default'].check(node.body);\n    }\n  },\n  SwitchStatement: {\n    is (node) {\n      return node.type === 'SwitchStatement';\n    },\n    check (node) {\n      for (const item of node.cases) {\n        for (const statement of item.consequent) {\n          if (lookupTable['@default'].check(statement)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  },\n  TryStatement: {\n    is (node) {\n      return node.type === 'TryStatement';\n    },\n    check (node) {\n      if (!lookupTable.TryStatement.is(node)) {\n        return false;\n      }\n\n      if (lookupTable.BlockStatement.check(node.block)) {\n        return true;\n      }\n\n      if (node.handler && node.handler.block) {\n        if (lookupTable['@default'].check(node)) {\n          return true;\n        }\n      }\n\n      if (lookupTable.BlockStatement.check(node.finalizer)) {\n        return true;\n      }\n\n      return false;\n    }\n  },\n  BlockStatement: {\n    is (node) {\n      return node.type === 'BlockStatement';\n    },\n    check (node, context) {\n      // E.g. the catch block statement is optional.\n      if (typeof node === 'undefined' || node === null) {\n        return false;\n      }\n\n      if (!lookupTable.BlockStatement.is(node)) {\n        return false;\n      }\n\n      for (const item of node.body) {\n        if (lookupTable['@default'].check(item, context)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  },\n  FunctionExpression: {\n    is (node) {\n      return node.type === 'FunctionExpression';\n    },\n    check (node, context) {\n      return node.async || lookupTable.BlockStatement.check(node.body, context);\n    }\n  },\n  ArrowFunctionExpression: {\n    is (node) {\n      return node.type === 'ArrowFunctionExpression';\n    },\n    check (node, context) {\n      // An expression always has a return value.\n      return node.expression ||\n        node.async ||\n        lookupTable.BlockStatement.check(node.body, context);\n    }\n  },\n  FunctionDeclaration: {\n    is (node) {\n      return node.type === 'FunctionDeclaration';\n    },\n    check (node, context) {\n      return node.async || lookupTable.BlockStatement.check(node.body, context);\n    }\n  },\n  '@default': {\n    check (node, context) {\n      // In case it is a `ReturnStatement`, we found what we were looking for\n      if (lookupTable.ReturnStatement.is(node)) {\n        return lookupTable.ReturnStatement.check(node, context);\n      }\n\n      // In case the element has children, we need to traverse them.\n      // Examples are BlockStatement, Choices, TryStatement, Loops, ...\n      for (const item of STATEMENTS_WITH_CHILDREN) {\n        if (lookupTable[item].is(node)) {\n          return lookupTable[item].check(node, context);\n        }\n      }\n\n      // Everything else cannot return anything.\n      if (RETURNFREE_STATEMENTS.includes(node.type)) {\n        return false;\n      }\n\n      // If we end up here, we stumbled upon an unknown elements\n      // Most likely it is enough to add it to the blacklist.\n      //\n      // throw new Error('Unknown node type: ' + node.type);\n      return false;\n    }\n  }\n};\n\n/**\n * Checks if the source code returns a return value.\n * It traverses the parsed source code and returns as\n * soon as it stumbles upon the first return statement.\n *\n * @param {Object} node\n *   the node which should be checked.\n * @returns {boolean}\n *   true in case the code returns a return value\n */\nconst hasReturnValue = (node, context) => {\n  // Loop through all of our entry points\n  for (const item of ENTRY_POINTS) {\n    if (lookupTable[item].is(node)) {\n      return lookupTable[item].check(node, context);\n    }\n  }\n\n  throw new Error('Unknown element ' + node.type);\n};\n\n/** @param {string} tag */\n/*\nconst isInlineTag = (tag) => {\n  return /^(@link|@linkcode|@linkplain|@tutorial) /.test(tag);\n};\n*/\n\nexport default {\n  getFunctionParameterNames,\n  getJsdocParameterNames,\n  getJsdocParameterNamesDeep,\n  getPreferredTagName,\n  hasATag,\n  hasDefinedTypeReturnTag,\n  hasReturnValue,\n  hasTag,\n  isNamepathDefiningTag,\n  isNamepathTag,\n  isPotentiallyEmptyNamepathTag,\n  isTagWithType,\n  isValidTag\n};\n"],"file":"jsdocUtils.js"}